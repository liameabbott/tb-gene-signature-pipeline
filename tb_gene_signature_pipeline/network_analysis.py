
import yaml
import numpy as np
import pandas as pd
import networkx as nx
from pathlib import Path
from subprocess import check_output

with (Path.cwd().resolve().parent / 'config.yml').open('r') as f:
    config = yaml.safe_load(f)

this_dir = Path(__file__).parent.absolute()
data_dir = Path(config['data_directory'])
data_dir.mkdir(parents=True, exist_ok=True)

# notebook 1
def run_differential_expression_analysis():
    """
    Run marginal, per-gene differential expression analyses.
    
    This function calls the differential analysis script
    ``tb-gene-signature-pipeline/R/differential_expression_analysis.R``.
    
    An independent case/control differential expression analysis is run for
    each dataset defined in ``data/datasets.json``, and for each group comparison
    defined in ``data/comparisons.json``.
    
    Return
    ------
    :class:`pd.DataFrame`
        A dataframe of differential expression effect sizes and p-values
        for each dataset and case/control comparison, with the columns:
        
            * Name: dataset, dtype: object
            * Name: control, dtype: object
            * Name: case, dtype: object
            * Name: gene_symbol, dtype: object
            * Name: log_fc, dtype: float
            * Name: adj_p_val, dtype: float
    
    Examples
    --------
    >>> import tb_gene_signature_pipeline as tb
    >>> df_results = tb.run_differential_expression_analysis()
    >>> df_results.head()
        dataset control case gene_symbol    log_fc  adj_p_val
    0  GSE19439      hc  atb        A1BG  0.026045   0.917217
    1  GSE19439      hc  atb        A1CF  0.091435   0.468395
    2  GSE19439      hc  atb         A2M  0.007356   0.964635
    3  GSE19439      hc  atb       A2ML1 -0.171059   0.204401
    4  GSE19439      hc  atb     A3GALT2 -0.008727   0.967318
    """
    r_script = this_dir / 'R' / 'differential_expression_analysis.R'

    results_file = Path(
        check_output(r_script).decode('utf8'))

    df = pd.read_table(results_file, sep='\t')
    results_file.unlink()
    
    return df

# notebook 2
def merge_differential_expression_results(
    differential_expression_df, adj_pval_thresh=0.05,
        log_fc_thresh=np.log2(1.5)):
    """
    Given a :class:`pd.DataFrame` of differential expression results
    (as generated by :func:`run_differential_expression_analysis`), return
    significant log fold change results.
    
    Parameters
    ----------
    differential_expression_df : :class:`pd.DataFrame`
        A dataframe of differential expression results, as generated by
        :func:`run_differential_expression_analysis()`.
    pval_thresh : float
        Adjusted p-value threshold for inclusion in merged dataframe.
    log_fc_thresh : float
        Effect size threshold for inclusion in merged dataframe.
        
    Return
    ------
    :class:`pd.DataFrame`
        A ``gene``-by-``dataset`` dataframe of log fold change effect sizes
        with the columns:
        
            * Name: control, dtype: object
            * Name: case, dtype: object
            * Name: gene_symbol, dtype: object
            * Name: ``<dataset GSE ID>``, dtype: float (one column per dataset)
        
    Example
    -------
    >>> import tb_gene_signature_pipeline as tb
    >>> df_results = tb.run_differential_expression_analysis()
    >>> merged_results = tb.merge_differential_expression_results(
    ...     adj_pval_thresh=0.05, log_fc_thresh=np.log2(1.5))
    >>> merged_results.head()
      control case gene_symbol  GSE107994  GSE29536  GSE34608  GSE42825  ...
    0      hc  atb   1060P11.3        0.0       0.0  0.000000  0.000000  ...
    1      hc  atb     A2M-AS1        0.0       0.0  0.000000  0.000000  ...
    2      hc  atb       AAED1        0.0       0.0  0.862417  0.000000  ...
    3      hc  atb       AAMDC        0.0       0.0  0.000000  0.694117  ...
    4      hc  atb        AAMP        0.0       0.0  0.000000  0.000000  ...
    """
    df = differential_expression_df.copy()
    
    df = df.loc[
        (df['log_fc'] >= log_fc_thresh) & (df['adj_p_val'] <= adj_pval_thresh)]
    
    df = (df
        .groupby(['control', 'case'])
        .apply(
            lambda x: x.pivot(
                index='gene_symbol', columns='dataset', values='log_fc'))
        .fillna(0.)
        .reset_index())
    
    return df

# notebook 5
def construct_networks(merged_results_df):
    """
    Construct networks based on shared association signal across
    differential expression analysis datasets. 
    
    One network is created for each case/control comparison
    (``hc`` vs. ``atb``, etc.).
    
    Within each network, a node represents a gene, and an edge between
    nodes represents indicates that those two genes had significant
    differential expression associations in the **same** direction in
    **at least 3** datasets. 
    
    Parameters
    ----------
    merged_results_df : :class:`pd.DataFrame`
        A gene-by-dataset dataframe of significant log fold change
        effect sizes, as produced by :func:`merge_differential_expression_results`.
        
    Return
    ------
    dict
        A dictionary with the entries:
            graphs : :class:`pd.DataFrame`
                Columns:
                    * Name: control, dtype: object
                    * Name: case, dtype: object
                    * Name: graph, dtype: :class:`nx.Graph`
            nodes : :class:`pd.DataFrame`
                Columns:
                    * Name: control, dtype: object
                    * Name: case, dtype: object
                    * Name: gene_symbol, dtype: object
                    * Name: degree, dtype: float
                    * Name: weighted_degree, dtype: float
                    * Name: eigenvector_centrality, dtype: float
    
    Example
    -------
    >>> import tb_gene_signature_pipeline as tb
    >>> differential_expression_results = tb.run_differential_expression_analysis()
    >>> merged_results = tb.merge_differential_expression_results(
    ...     differential_expression_results, adj_val_thresh=0.05,
    ...     log_fc_thresh=np.log2(1.5))
    >>> networks = tb.construct_networks(merged_results)
    >>> print(networks['graphs'])
      control  case                                              graph
    0      hc   atb  (AAMDC, ABCA1, ACOT8, ACOT9, ACSL1, ACTA2, ADA...
    1      hc  ltbi                                     (ATP1B2, ETV7)
    2    ltbi   atb  (ABCA1, ABCA13, ABCC13, ACSL1, ACSL4, ADAM9, A...
    3      od   atb  (ADM, AIM2, ANKRD22, APOL6, ATF3, BATF2, BRSK1...
    >>> print(networks['nodes'])
         control case gene_symbol  degree  weighted_degree  eigenvector_centrality
    0         hc  atb       AAMDC     503        94.312500            1.404467e-02
    1         hc  atb       ABCA1    1318       349.187500            4.088542e-02
    2         hc  atb       ACOT8     503        94.312500            1.404467e-02
    3         hc  atb       ACOT9    1099       271.000000            3.351424e-02
    4         hc  atb       ACSL1    1327       354.187500            4.143864e-02
    ...      ...  ...         ...     ...              ...                     ...
    3409      od  atb        RGL1       5         1.666667            1.456176e-03
    3410      od  atb        TLR5       5         1.666667            1.456176e-03
    3411      od  atb        CD3G       4         1.333333            1.917126e-11
    3412      od  atb        GNLY       4         1.333333            1.917126e-11
    3413      od  atb        NRG1       4         1.333333            1.917126e-11
    
    """
    df_ = merged_results_df.copy()
    
    def generate_network_per_comparison(xdf):
        xdf_ = xdf.copy().reset_index()

        m = xdf_.drop(['control', 'case', 'gene_symbol'], axis=1).values
        n_datasets = (m.sum(axis=0) > 0).sum()

        m[m > 0] = 1
        m[m == 0] = 0
        m[m < 0] = -1

        edge_weights = m.dot(m.T)
        edge_weights_mask = np.abs(edge_weights) >= 3

        edge_indices = zip(*np.triu(edge_weights_mask).nonzero())
        gene_symbols = xdf_['gene_symbol']

        network_edge_list = [
            (gene_symbols[i], gene_symbols[j], float(edge_weights[i,j])/n_datasets)
            for i, j in edge_indices]

        graph = nx.Graph()
        graph.add_weighted_edges_from(network_edge_list)

        return graph
    
    graphs = (df_
        .groupby(['control', 'case'])
        .apply(generate_network_per_comparison)
        .reset_index()
        .rename({0: 'graph'}, axis=1))
    
    def compute_degrees(graphs, weight=None):
        colname = 'weighted_degree' if weight == 'weight' else 'degree'
        df_degrees = (graphs
            .set_index(['control', 'case'])
            .apply(lambda x: (pd
                .DataFrame(
                    x['graph'].degree(weight=weight))
                .to_records(index=False)), axis=1)
            .reset_index()
            .explode(0)
            .reset_index(drop=True))
        df_degrees['gene_symbol'] = df_degrees[0].apply(lambda x: x[0])
        df_degrees[colname] = df_degrees[0].apply(lambda x: x[1])
        df_degrees = df_degrees[['control', 'case', 'gene_symbol', colname]]
        
        return df_degrees
    
    df_degrees = compute_degrees(graphs, weight=None)
    df_weighted = compute_degrees(graphs, weight='weight')
    
    df_eigens = (graphs
        .set_index(['control', 'case'])
        .apply(lambda x: [
            (k, v) for k, v in nx.eigenvector_centrality(
                x['graph'], weight='weight').items()],
            axis=1)
        .reset_index()
        .explode(0)
        .reset_index(drop=True))
    df_eigens['gene_symbol'] = df_eigens[0].apply(lambda x: x[0])
    df_eigens['eigenvector_centrality'] = df_eigens[0].apply(lambda x: x[1])
    df_eigens = df_eigens[['control', 'case', 'gene_symbol', 'eigenvector_centrality']]
    
    df_nodes = (df_degrees
        .merge(
            df_weighted, on=['control', 'case', 'gene_symbol'])
        .merge(
            df_eigens, on=['control', 'case', 'gene_symbol']))
    
    return {
        'graphs': graphs,
        'nodes': df_nodes
    }

# notebook 6
def combine_networks_into_lists(networks, n_nodes=100):
    """
    Generate gene lists based on intersections and differences between the
    top ``n_nodes`` nodes in each comparison network (``hc`` vs. ``atb``,
    ``od`` vs. ``atb``, and `ltbi`` vs. ``atb`` - exclude the almost
    nonexistent ``hc`` vs. ``ltbi`` network).
    
    Parameters
    ----------
    graphs : dict
        A dictionary of network graphs and node metrics, as returned by
        :func:`construct_networks`.
    n_nodes : int
        Gene lists will be generated based on the top ``n_nodes`` nodes
        by weighted degree in each comparison network.
        
    Return
    ------
    dict
        A dictionary of gene lists with two entries:
        
        ``'top_genes_in_all_networks'``: The intersection of the top
            ``n_nodes`` genes by weighted degree in the ``hc`` vs. ``atb``,
            ``ltbi`` vs. ``atb``, and ``od`` vs. ``atb`` networks.
        
        ``'top_genes_not_in_od_network'``: The intersection of the top 
            ``n_nodes`` genes by weighted degree in the ``hc`` vs. ``atb``
            and ``ltbi`` vs. ``atb`` networks, minus the genes in the top
            ``n_nodes`` of the ``od`` vs. ``atb`` network.

    Example
    -------
    >>> import tb_gene_signature_pipeline as tb
    >>> differential_expression_results = tb.run_differential_expression_analysis()
    >>> merged_results = tb.merge_differential_expression_results(
    ...     differential_expression_results, adj_val_thresh=0.05,
    ...     log_fc_thresh=np.log2(1.5))
    >>> networks = tb.construct_networks(merged_results)
    >>> gene_lists = tb.combine_networks_into_lists(networks, n_nodes=100)
    >>> print(gene_lists['top_genes_in_all_networks'][:5])
    ['SAMD9L', 'KCNJ15', 'LAP3', 'CEACAM1', 'SERPING1']
    >>> print(gene_lists['top_genes_not_in_od_network'][:5])
    ['TLR5', 'JAK2', 'S100A12', 'ZNF438', 'SORT1']
    
    """
    
    df_ = networks['nodes'].copy()
    df_ = df_.loc[~((df_['control'] == 'hc') & (df_['case'] == 'ltbi'))]
    
    top_nodes = (df_
        .set_index(['control', 'case'])
        .sort_values('weighted_degree', ascending=False)
        .groupby(['control', 'case'])
        .head(n_nodes)
        .reset_index())[['control', 'case', 'gene_symbol']]
    
    hc_atb_nodes = set(top_nodes.loc[
        (top_nodes['control'] == 'hc') & (top_nodes['case'] == 'atb')]['gene_symbol'])
    
    ltbi_atb_nodes = set(top_nodes.loc[
        (top_nodes['control'] == 'ltbi') & (top_nodes['case'] == 'atb')]['gene_symbol'])
    
    od_atb_nodes = set(top_nodes.loc[
        (top_nodes['control'] == 'od') & (top_nodes['case'] == 'atb')]['gene_symbol'])
    
    top_genes_all_networks = hc_atb_nodes.intersection(ltbi_atb_nodes, od_atb_nodes)
    top_genes_not_od_network = hc_atb_nodes.intersection(ltbi_atb_nodes) - od_atb_nodes
    
    return {
        'top_genes_in_all_networks': list(top_genes_all_networks),
        'top_genes_not_in_od_network': list(top_genes_not_od_network)
    }
    